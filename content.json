{"meta":{"title":"Have a nice day :)","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-05-18T04:31:47.538Z","updated":"2021-05-18T04:31:47.529Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面跑丢了 可能是输入已被删除或正在建设中～～"},{"title":"所有分类","date":"2021-05-20T06:40:58.610Z","updated":"2021-05-18T04:13:48.374Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-18T04:13:20.150Z","updated":"2021-05-18T04:09:37.179Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Hello~~"},{"title":"我的小伙伴们","date":"2021-05-18T04:18:25.426Z","updated":"2021-05-18T04:18:25.417Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2021-05-18T04:13:15.154Z","updated":"2021-05-18T04:13:15.150Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HTML学习笔记(2)——HTML常用标签","slug":"HTML学习笔记(2)——HTML常用标签","date":"2021-05-19T16:00:00.000Z","updated":"2021-05-22T16:00:00.000Z","comments":true,"path":"2021/05/20/HTML学习笔记(2)——HTML常用标签/","link":"","permalink":"http://example.com/2021/05/20/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%E2%80%94%E2%80%94HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/","excerpt":"","text":"标题标签123456&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二集标题&lt;/h2&gt;...&lt;h6&gt;六级标题&lt;/h6&gt; 段落标签和换行标签 段落标签 html并不会依据输入的文本格式进行分段，因此需要段落和换行标签 1&lt;p&gt;段落标签&lt;/p&gt; 段落标签 html文本默认根据浏览器窗口的大小自动换行，因此需要换行标签，换行标签后的文字会被强制换行 1&lt;br /&gt; 段与段之间的空隙要比换行标签造成的空隙大 文本格式化标签 作用 标签 加粗 &lt; strong&gt;&lt; /strong&gt;或&lt; b&gt;&lt; /b&gt; 倾斜 &lt; em&gt;&lt; /em&gt;或&lt; i&gt;&lt; /i&gt; 删除线 &lt; del&gt;&lt; /del&gt;或&lt; s&gt;&lt; /s&gt; 下划线 &lt; ins&gt;&lt; /ins&gt;或&lt; u&gt;&lt; /u&gt; 以上标签可以符合使用 1&lt;em&gt;&lt;strong&gt;加粗又倾斜&lt;/strong&gt;&lt;/em&gt; 布局标签12&lt;div&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt; 图像标签图像标签的属性： 属性 属性值 备注 src 图片路径 必须填写的属性 alt 文本 替换文本，当图片不能正常显示时显示该文字 title 文本 提示文本，当光标置于图像上时显示的文字 width 像素 设置图像的宽度 height 像素 设置图像的高度 border 像素 设置图像的边框的粗细 宽度和高度如果只修改其中一项，另一项会自动等比例缩放 语法： 1&lt;img src=&quot;图像URL&quot; alt=&quot;替换文本&quot;/&gt; 搭建网站时注意汇总图片素材文件 相对路径以引用文件为参考建立起的目录文件，即该素材或文件相对于HTML页面的位置 以图片为例 相对路径分类 符号 说明 例 同级路径 素材或文件位于该引用HTML文件的同一级 &lt; img src=”123.png” /&gt; 下一级路径 / 素材或文件位于该引用HTML文件的同下一级 &lt; img src=”images/123.png” /&gt; 上一级路径 ../ 素材或文件位于该引用HTML文件的同上一级 &lt; img src=”../images/123.png” /&gt; 绝对路径指目录下的绝对位置，通常是从盘符或完整的网址https://www........开始 超链接标签一、链接的语法格式 1&lt;a href=&quot;跳转的目标&quot; targget=&quot;窗口的弹出方式&quot;&gt; 文本或图像&lt;/a&gt; 属性 作用 herf 用于前往指定的url地址 target 用于指定页面的打开方式__ self为当前页面打开，__blank为在新窗口中打开 二、超链接的分类 外部链接 1&lt;a href=&quot;http://www...&quot; target=&quot; &quot;&gt; 文本/图片&lt;/a&gt; 内部链接 1&lt;a href=&quot;页面名称.html&quot; target=&quot; &quot;&gt; 文本/图片&lt;/a&gt; 空链接 1&lt;a href=&quot;#&quot; target=&quot; &quot;&gt; 文本/图片&lt;/a&gt; 下载链接 1&lt;a href=&quot;文件名&quot; target=&quot; &quot;&gt; 文本/图片&lt;/a&gt; 网页元素用作链接 1&lt;a href=&quot;文件名&quot; target=&quot; &quot;&gt; 元素&lt;/a&gt; 锚点链接 快速定位到页面的某个位置 12&lt;a href=&quot;#ID&quot; target=&quot; &quot;&gt; 元素&lt;/a&gt; //定位到ID标签处&lt;h3 id=ID&gt;内容&lt;h3&gt; //添加ID属性 注释标签不会在网页中显示的内容 1&lt;!--注释内容--&gt; 快捷键：ctrl + /或者command + / 特殊符号标签因为字符代码会被markdown格式识别故&amp;后有空格，实际使用不能有空格 特殊字符 描述 字符代码 &nbsp; 空格 &amp; nbsp; &lt; 小于号 &amp; lt; &gt; 大于号 &amp; gt; &amp; 和 &amp; amp; &yen; 人民币 &amp; yen; &reg; 注册商标 &amp; reg; &copy; 版权 &amp; copy; &deg; 摄氏度 &amp; deg; &plusmn; 正负号 &amp; plusmn; &times; 乘号 &amp; times; &divide; 除号 &amp; divide; &sup2; 平方 &amp; sup2; &sup3; 立方 &amp; sup3;","categories":[{"name":"HTML学习记录","slug":"HTML学习记录","permalink":"http://example.com/categories/HTML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[],"author":"UDK"},{"title":"HTML学习笔记(1)——语法规范","slug":"HTML学习笔记(1)——语法规范","date":"2021-05-19T16:00:00.000Z","updated":"2021-05-20T16:00:00.000Z","comments":true,"path":"2021/05/20/HTML学习笔记(1)——语法规范/","link":"","permalink":"http://example.com/2021/05/20/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/","excerpt":"","text":"标签规范 HTML标签是由尖括号包围的关键词 如&lt; html&gt; 标签通常是成对出现的&lt; html&gt;&lt; /html&gt;此为双标签，第一个标签是开水标签，第二个标签叫做结束标签 有些特殊标签是单个标签如&lt; br/&gt; 标签关系相对关系 包含关系 123&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; 并列关系 12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 基本结构标签 标签名 定义 备注 &lt; html&gt;&lt; /html&gt; HTML标签 页面中对最大的标签，也称为根部标签 &lt; head&gt;&lt; /head&gt; 头部 在head标签中必须设置title标签 &lt; title&gt;&lt; /title&gt; 标题 网页标题 &lt; body&gt;&lt; /body&gt; 主体 文档中所有的元素基本都放在body标签内 例 123456&lt;html&gt; &lt;head&gt; &lt;title&gt;第一个页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt;不要再卷了！&lt;/body&gt;&lt;/html&gt; 运行效果","categories":[{"name":"HTML学习记录","slug":"HTML学习记录","permalink":"http://example.com/categories/HTML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（十三）——异常","slug":"Java——基础知识（十三）——异常","date":"2021-05-12T16:00:00.000Z","updated":"2021-05-12T16:00:00.000Z","comments":true,"path":"2021/05/13/Java——基础知识（十三）——异常/","link":"","permalink":"http://example.com/2021/05/13/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8/","excerpt":"","text":"异常 Java将程序运行过程中的非正常情况封装成异常类，并通过异常处理机制对程序运行时发生的各种问题进行处理两种常见异常类 Error(错误类)： 此类表示java运行时产生的系统内部错误或资源耗尽的错误，一般此类错误仅靠修改程序本身是不能被修复的，如系统崩溃 Exception(异常类)： 此类表示程序本身可以处理的错误，该类下除了RuntimeExpecption子类表示运行时错误外，其他子类都表示编译错误异常的类型编译异常 在程序编写过程中，Java编译器就会对程序进行检查，如果出现了比较明显的异常就必须对异常进行处理 处理方式：* 使用try…catch对异常进行捕获，使用throws关键字声明抛出异常，让调用者对其进行处理运行时异常： 在程序运行时由Java虚拟机自动捕获处理的，这种错误即使没有使用try…catch语句捕获或throws关键字声明抛出，程序也能编译通过，但是在运行时可能报错 常见的运行时异常 异常类名称 异常类说明 ArithmeticException 算数异常 IndexOutOfBoundException 角标越界异常 ClassCastException 类型转换异常 NullPointerException 空指针异常 NumberFormatException 数字格式化异常 try…catch语句和finally语句try…catch 当程序发生异常时会立即终止，这会影响开发效率，因此Java提供了一种对异常进行处理的方式——异常捕获 异常被try…catch捕获并处理后程序仍能正常向下执行！ try…catch语句的声明123456789try&#123; //可能发生异常的语句&#125;catch(Expection类或其子类 e)&#123; //对异常进行处理的语句&#125; try…catch语句的使用12345678910111213141516171819202122public class Main&#123; public static void main(String [] args) &#123; int x,y,z; x=1; y=0; try &#123; z=x/y; System.out.println(&quot;在发生异常的代码后方的代码是不执行的&quot;); &#125; catch(Exception e) &#123; System.out.println(&quot;除数不能为零&quot;); &#125; System.out.println(&quot;异常捕获后仍能继续运行&quot;); &#125;&#125; 输出 除数不能为零异常被捕获后仍能继续运行 注意： 通常用于确定的有可能出现异常的代码 在try中的代码出现异常时，程序会转而执行catch中的代码 在执行完catch中的代码之后程序仍会继续向下运行 在try中出现异常的代码的后方的代码是不会被执行的 finally 有时会希望某些语句不论程序是否发生异常都要执行，为此仅需在catch代码块的下方添加finally代码块即可 finally语句的声明12345678910111213try&#123; //可能发生异常的语句&#125;catch(Expection类或其子类 e)&#123; //对异常进行处理的语句&#125;finally&#123; //无论如何都要执行的语句&#125; finally语句的使用12345678910111213141516171819202122232425public class Main&#123; public static void main(String [] args) &#123; int x,y,z; x=1; y=0; try &#123; z=x/y; System.out.println(&quot;在发生异常的代码后方的代码是不执行的&quot;); &#125; catch(Exception e) &#123; System.out.println(&quot;除数不能为零&quot;); &#125; finally &#123; System.out.println(&quot;无论如何都要执行的语句&quot;); &#125; System.out.println(&quot;异常捕获后仍能继续运行&quot;); &#125;&#125; 输出 除数不能为零无论如何都要执行的语句异常捕获后仍能继续运行 throws关键字注意： 用在方法声明中，用于指明方法可能出现的多种异常 通常用于不确定某处代码是否出现异常或出现的异常并不急于处理 用于整个方法而不是某段代码块 可以一次性抛出多种异常 表现为在编译时报错 语法格式 用在方法声明的后面，throws的后面需要声明方法中发生的异常的类型 1234[修饰符]返回值类型 方法名([参数类型 参数名1 ...])throws 异常类1,异常类2...&#123; 方法的内容&#125; 123456789101112public class Main&#123; public static int f(int a,int b) throws Exception &#123; return a/b; &#125; public static void main(String [] args) &#123; System.out.printf(&quot;%d\\n&quot;,f(1,0)); &#125;&#125; 编译结果为提示第十行出错 如果去掉throws关键字则可以正常编译，但是运行时会出错 throw关键字 throws关键字用于方法，throw关键字用于方法体内的某个异常对象 需要与throws和try…catch搭配使用 提高了程序的可读性123456789101112131415161718192021222324public class Main&#123; public static int f(int a,int b) throws Exception &#123; if(b==0) throw new Exception(&quot;除数不能为零&quot;); int z=a/b; return a/b; &#125; public static void main(String [] args) &#123; try &#123; f(1,0); &#125; catch(Exception e) &#123; System.out.println(&quot;错误信息为：&quot;+e.getMessage()); &#125; &#125;&#125; 输出 错误信息为：除数不能为零","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（十一）——内部类","slug":"Java——基础知识（十一）——内部类","date":"2021-05-11T16:00:00.000Z","updated":"2021-05-11T16:00:00.000Z","comments":true,"path":"2021/05/12/Java——基础知识（十一）——内部类/","link":"","permalink":"http://example.com/2021/05/12/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"内部类内部类是在类的内部定义的类，即套娃类中类，内部类所在的类称为外部类 内部类的四种形式 成员内部类 局部内部类（方法内部类） 静态内部类（static） 匿名内部类 成员内部类 普通的内部类，直接在类的内部创建类，其“级别”与该类内其他成员同级 其内部成员能够访问成员的范围是该内部类的外部类的所有成员 其内部成员能够被访问的范围是该内部类的外部类的所有成员成员内部类的形式 以定义成员方法或成员变量的“方式“定义类 内外类成员的访问只能借助于方法，不能直接由类名访问1234567class A //外部类&#123; class B //内部类 &#123; &#125;&#125; 成员内部类的使用实例化（创建对象）成员内部类的语法1外部类名.内部类名 变量名 = new 外部类名().new 内部类名(); 123456789101112131415161718192021222324252627282930313233class A //外部类&#123; int m=0; public void f() &#123; B b = new B(); System.out.printf(&quot;%d\\n&quot;,b.n); //外部类的方法要访问你内部类需要先实例化内部类 System.out.print(&quot;Out\\n&quot;); &#125; class B //内部类 &#123; int n=1; public void g() &#123; System.out.printf(&quot;%d\\n&quot;,m); //内部类借由方法访问了外部类的变量 System.out.print(&quot;In\\n&quot;); &#125; &#125;&#125;public class Main&#123; public static void main(String [] args) &#123; A a = new A(); //创建外部类对象 A.B b =a.new B(); //用外部类对象创建内部类对象 A.B b2 = new A().new B(); //直接创建内部类对象 a.f(); b.g(); &#125;&#125; 输出 1Out0In 局部内部类 局部内部类又叫方法方法内部类，即在方法的内部创建类，其“级别”与局部变量同级局部内部类的形式 其声明方式与方法内其他成员的声明方式相同 其能够访问的范围与成员内部类相同，即该内部类的外部类的所有成员 其能够被访问的范围仅为创建该内部类的方法内的成员 1234567class A&#123; public void f() &#123; class B&#123;&#125; //创建局部内部类 &#125;&#125; 局部内部类的使用123456789101112131415161718192021222324252627282930class A&#123; public void f() &#123; int n=1; class B &#123; int m; public void g() &#123; System.out.printf(&quot;n = %d\\n&quot;,n); &#125; &#125; B b = new B(); b.g(); //只能在创建该基部内部类的方法内才能访问该内部类的成员 System.out.printf(&quot;m = %d\\n&quot;,b.m); &#125;&#125;public class Main&#123; public static void main(String [] args) &#123; A a = new A(); //无法直接实例化局部内部类 a.f(); &#125;&#125; 输出 n = 1m = 0 静态内部类 由static关键字修饰的成员内部类 其内部成员只能访问外部类的静态成员 其内部成员在被访问时，能够跳过外部类直接被访问到静态内部类的声明 1234567class A //外部类&#123; static class B //静态内部类 &#123; &#125;&#125; 静态内部类的使用实例化（创建对象）静态内部类的语法 1外部类名.静态内部类名 变量名 = new 外部类名.静态内部类名(); 以上语法表明静态内部类可以经由外部类直接创建，因此节省了时间12345678910111213141516171819202122class A //外部类&#123; static int n = 0; static class B //静态内部类 &#123; public void f() &#123; System.out.printf(&quot;n = %d\\n&quot;,n); //通过方法访问外部类的静态变量 &#125; &#125;&#125;public class Main&#123; public static void main(String [] args) &#123; A.B b = new A.B(); //外部类直接创建内部类 b.f(); &#125;&#125; 输出 n = 1 匿名内部类 没有名称的内部类 充当接口类型的参数写在方法的传入参数部分 当调用某个方法时，如果该方法的参数是一个接口类型，除了传入一个参数接口实现类还可通过匿名内部类的形式传入一个接口类型参数，直接在匿名内部类中完成方法的实现，通过此举可以简化代码 匿名内部类的形式123interface 接口名&#123;&#125; //首先声明一个接口参数类型为接口的方法名( new 接口名()&#123;实现方法&#125; ) 说明： 调用以接口为参数的方法时，在方法的参数位置写入 1new 接口名()&#123;实现方法&#125; 相当于创建了一个实例对象，并将此对象作为参数传给该方法 后方的大括号表示创建的是接口的子类实例，且该子类是匿名的 大括号中的内容是匿名子类的实现代码(接口功能的实现代码) 这一部分好丑好长好难懂啊啊匿名内部类的使用 123456789101112131415161718192021222324interface Z&#123; void f();&#125;public class Main&#123; public static void main(String [] args) &#123; int n = 1; g(new Z()&#123; //g()为参数类型为接口类型的方法 public void f() &#123; System.out.printf(&quot;n = %d&quot;,n); &#125; &#125;); &#125; public static void g(Z z) //注意在main方法的外部 &#123; z.f(); &#125;&#125; 输出 n = 1","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（十）——多态、对象类型转换","slug":"Java——基础知识（十）——多态、对象类型转换","date":"2021-05-09T16:00:00.000Z","updated":"2021-05-09T16:00:00.000Z","comments":true,"path":"2021/05/10/Java——基础知识（十）——多态、对象类型转换/","link":"","permalink":"http://example.com/2021/05/10/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81%E3%80%81%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"多态 Java的多态是由类的继承、 方法的重写、父类的引用（类似指针）指向子类对象体现的 类的继承和方法重写体现多态123456789101112131415161718192021222324252627282930313233class A&#123; public void f() &#123; System.out.print(&quot;A\\n&quot;); &#125; public void g() &#123; System.out.print(&quot;C\\n&quot;); &#125;&#125;class B extends A&#123; public void f() &#123; System.out.print(&quot;B\\n&quot;); &#125;&#125;public class Main&#123; public static void main(String [] args) &#123; A a = new A(); B b = new B(); a.f(); b.f(); b.g(); &#125;&#125; 输出 ABC 对象类型转换 将子类对象当作父类类型使用（向上转型） 1234567891011class A&#123;&#125;class B extends A&#123;&#125;public class Main &#123; public static void main(String [] args) &#123; A b = new B(); //注意此处通常为A() &#125;&#125; 注意： 此时父类对象（A）并不能调用对象B中特有 的方法 instanceof关键字 在使用引用进行强制类型转换时，父类向下转换时必须转换为本质类型，为判断一个对象是否是某个类或接口的实例或子类实例（本质类型），引用instanceof进行判断1234567891011121314151617181920212223对象（或对象引用变量） instanceof类（或接口）-----------------------------------------class A&#123;&#125;class B extends A&#123;&#125;class C extends A&#123;&#125;public class Main&#123; public static void main(String [] args) &#123; A a = new B(); if(a instanceof C) //判断是不是本质类型 &#123; C c = (C) a; //通过引用进行对象类型转换 &#125; else &#123; System.out.print(&quot;1&quot;); &#125; &#125;&#125;","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（七）——this和satic关键字","slug":"Java——基础知识（七）——this和satic关键字","date":"2021-05-08T16:00:00.000Z","updated":"2021-05-08T16:00:00.000Z","comments":true,"path":"2021/05/09/Java——基础知识（七）——this和satic关键字/","link":"","permalink":"http://example.com/2021/05/09/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94this%E5%92%8Csatic%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"this 关键字 解决成员变量和成员变量所在类外的同名变量冲突的问题12345678class A&#123; private int a; public void into(int a) &#123; this.a=a; //第一个a为该类内部的成员变量，第二个a为类外局部变量 &#125;&#125; 成员方法也可以相同的方式调用 12345678910class A&#123; private int a; public void into(int a) &#123; this.a=a; &#125; this.into();&#125; this调用构造方法的注意事项 只能在构造方法中使用this调用其他的构造方法 使用this调用构造方法的语句必须是该方法的第一条语句且只出现一次 不能在一个类的两个构造方法中使用this互相调用 static（静态）关键字当同一个对象被多次实例化之后，其内部的成员变量和成员方法也会在内存中出现多个，若只想让该成员出现一次，如同一所学校的所有学生信息中仅需一个“学校名称”变量，此时便可使用staric关键字 静态变量1234[修饰符] static 变量类型变量名 //静态变量的创建类名.变量名 //静态变量的访问实例对象名.变量名 //普通成员变量的访问 静态方法1234567[修饰符] static 返回值 方法名() //创建静态方法&#123; 方法体&#125;类名.方法名() //访问静态方法实例对象名.方法名() 注意：静态方法不需要创建对象（实例化对象）就能直接调用类名使用静态代码块当类被加载时（第一次运行程序），静态代码块会和类一起被加载，且因为类只会加载一次，所以静态代码块也只会加载一次。通常使用其来对类中的变量进行初始化。有别于构造方法，构造方法在每次实例化对象的时候都会运行，但是静态代码块在程序运行全程仅运行一次12345static &#123; 代码块内容&#125;","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（九）——抽象类与抽象方法、接口","slug":"Java——基础知识（九）——抽象类与抽象方法、接口","date":"2021-05-08T16:00:00.000Z","updated":"2021-05-08T16:00:00.000Z","comments":true,"path":"2021/05/09/Java——基础知识（九）——抽象类与抽象方法、接口/","link":"","permalink":"http://example.com/2021/05/09/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"抽象方法 没有方法体的方法 抽象方法要求结尾必须加分号 修饰符必须带有abstract 必须在抽象类内，抽象类内不一定全是抽象方法1234abstract class A&#123; abstract public void f();&#125; 抽象类 不能实例化对象的类 利用抽象类可以更加方便地对类进行分类 抽象类通常是一个类组最顶层的父类 抽象类内可以有非抽象方法1234567891011abstract class A&#123; abstract public void f(); //抽象方法 public void f2() //非抽象方法 &#123; &#125; int a;&#125; 接口（interface）更加严格的抽象方法接口要求 接口中的属性（成员变量）必须是public static final 的 接口中定义的方法必须是 public abstract 以上修饰符可以省略不写 接口中的属性不能被更改 一个类只能实现（implements）某个接口，不能继承接口 接口可以继承接口，且可以一次继承多个接口 一个类只实现了一个接口的部分方法，那么该类必须被声明为抽象类 一个类可以在继承某个父类的同时实现某个或多个接口，但是extends关键字必须在implements之前 不可以new接口（对接口实例化），但是可以定义一个接口引用类型的变量并将其指向实现接口的对象，以达到多态的目的 定义接口12345interface It&#123; int i=20; abstract void f();&#125; 接口的实现和使用12345678910111213141516171819202122232425262728interface It&#123; int i=20; abstract void f();&#125;class A implements It //实现接口&#123; public void f() &#123; System.out.printf(&quot;%d\\n&quot;,i); &#125;&#125;class B extends A implements It //先继承再实现&#123;&#125;public class Main&#123; public static void main(String [] args) &#123; A a = new A(); a.f(); &#125;&#125; 接口的继承123456789101112131415161718192021222324interface A&#123; &#125;interface B extends A&#123; &#125;interface C extends B //C接口此时拥有A和B接口的所有属性&#123; &#125;interface D&#123;&#125;class I implements B,D //I此时实现了ABCD接口&#123; &#125;","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（八）——类的继承、父类的重写、Object类、final关键字","slug":"Java——基础知识（八）——类的继承、父类的重写、Object类、final关键字","date":"2021-05-08T16:00:00.000Z","updated":"2021-05-08T16:00:00.000Z","comments":true,"path":"2021/05/09/Java——基础知识（八）——类的继承、父类的重写、Object类、final关键字/","link":"","permalink":"http://example.com/2021/05/09/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E3%80%81%E7%88%B6%E7%B1%BB%E7%9A%84%E9%87%8D%E5%86%99%E3%80%81Object%E7%B1%BB%E3%80%81final%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"类的继承概念 类的继承是指在现有类的基础上构建一个新类 继承主要描述类与类之间的关系，利用继承可以在不改变原有类的功能的前提下，对该类进行扩展，被继承的类称为父类，继承的类称为子类，父类和子类是一个相对的概念 子类在继承父类时便拥有了父类中所有的成员变量和方法实现12345678910111213141516171819202122232425262728293031[修饰符] class 子类名 extends 父类名&#123; //子类代码&#125;-----------------------------------------------class A&#123;&#125;class B extends A &#123;&#125;class C extends B &#123;&#125; //C拥有A和B的所有内容-----------------------------------------------class A&#123; public void f() &#123; System.out.print(&quot;A\\n&quot;); &#125;&#125;class B extends A&#123;&#125;public class Main&#123; public static void main(String [] args) &#123; B b = new B(); //此处仅实例化对象B,注意B中并未声明任何方法 b.f(); &#125;&#125; 输出 A 注意： Java中一个类只能继承于一个父类，不允许同时继承多个类 同一个父类可以被多个子类继承 可以千层饼多层继承重写父类方法重父类中方法的方法或成员变量条件重写方法/成员变量需要和父类被重写的方法名称/成员变量名称、参数列表和返回值类型均相同实现12345678910111213141516171819202122232425262728293031class A&#123; int c=1; public void a() &#123; System.out.printf(&quot;%d\\n&quot;,c); &#125;&#125;class B extends A&#123; int c=2; public void a() &#123; System.out.printf(&quot;%d\\n&quot;,c); &#125;&#125;public class Main&#123; public static void main(String [] args) &#123; A test1 = new A(); B test2 = new B(); A test3 = new A(); test1.a(); test2.a(); test3.a(); &#125;&#125; 输出 121 从输出中可见虽然子类对父类的方法进行了重写，但是并不会改变原有父类中的方法 super关键字在子类重写父类的方法后，子类就不能直接访问父类中原有的方法了，因此使用super关键字用来在子类中调用重写父类方法前父类的方法，构造方法也是同理 123super.成员变量super.成员方法()super（[参数列表]） //调用构造方法 注意： 通过super调用父类的构造方法的代码必须位于子类构造方法的第一行，并且只能出现一次 Object类Object类时所有类的父类，所有类如果没有说明（extends）继承于某个类，默认继承Object类，如果说名明了，那Object类也是父类的父类 Object类中的常用方法 方法声明 功能描述 bolean equals(Object obj) 判断某个对象与此对象是否相等 final Class&lt;?&gt;getClass() 返回此 Object 的运行时类 int hashCode() 将对象的内存地址进行哈希运算并返回一个int类型的哈希码 String toString() 以字符串的形式返回对象的基本信息 void finalize() 清理没有被任何引用变量所引用的对象的资源（内存回收） final关键字作用被final修饰的类、变量或方法具有以下特征 被修饰的类不能被继承 被修饰的方法不能被子类重写 被修饰的变量只能被赋值一次（变为常量）,且在定义时必须初始化 12345678910 final class A&#123; final public int c = 0; //final和访问限制符都是修饰符 public final int c = 0; public final void a() &#123; &#125;&#125;","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（五）——类的封装","slug":"Java——基础知识（五）——类的封装","date":"2021-05-07T16:00:00.000Z","updated":"2021-05-07T16:00:00.000Z","comments":true,"path":"2021/05/08/Java——基础知识（五）——类的封装/","link":"","permalink":"http://example.com/2021/05/08/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"","text":"封装的必要性令该类的成员变量或内部信息不能被外界访问，外界只能通过该类提供的方法（函数）对该类的内部信息进行操作，以此来保证程序的正常运行。 封装的实现通过将内部属性（成员变量）私有化（private），使外部不能直接访问其内部变量，并提供一些公共（public）的方法使外界有限制条件地间接访问和操作该类的内部成员。 12345678910111213141516171819202122232425262728import java.util.Scanner;class A&#123; private int a; //将该成员变量设为私有以阻止外界直接访问该变量 public void into(int a) //将该方法设为公有以使外界能够访问 &#123; //括号内用于接收传入的变量 this.a=a; //将外部输入的值赋给该类的成员变量 &#125; public void output() &#123; System.out.printf(&quot;%d&quot;,a); //输出该成员变量此时的值 &#125;&#125;public class Main&#123; public static void main(String [] args) &#123; Scanner in = new Scanner(System.in); A b = new A(); b.into(in.nextInt()); //输入数据 b.output(); &#125;&#125; 输入 3 输出 3","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（六）——方法的重载、递归、构造方法","slug":"Java——基础知识（六）——方法的重载、递归、构造方法","date":"2021-05-07T16:00:00.000Z","updated":"2021-05-07T16:00:00.000Z","comments":true,"path":"2021/05/08/Java——基础知识（六）——方法的重载、递归、构造方法/","link":"","permalink":"http://example.com/2021/05/08/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/","excerpt":"","text":"方法的重载方便编程与使用的一种自动的机制，程序会自动根据输入数据类型和数量的不同调用相应的方法 条件 方法的名称相同 方法的传入参数类型或个数不同 与方法的返回值或类型无关 实现123456789101112131415161718192021222324public class Main&#123; public static String A(int a) &#123; return &quot;INT\\n&quot;; &#125; public static String A(double a) &#123; return &quot;DOUBLE\\n&quot;; &#125; public static String A(int a,int b) &#123; return &quot;TWO INT\\n&quot;; &#125; public static void main(String [] args) &#123; System.out.print(A(1)); System.out.print(A(1.5)); System.out.print(A(1, 3)); &#125;&#125; 输出 INTDOUBLETWO INT 方法的递归Java中的递归思想与实现方式C语言无异 123456789101112131415public class Main&#123; public static int A(int n,int m)&#123; if(m==0||n==1||m==n) return 1; else return A(n-1,m-1)+A(n-1,m);&#125; public static void main(String [] args) &#123; System.out.printf(&quot;%d&quot;,A(4,5)); &#125;&#125; 输出 8 构造方法 在实例化对象时对对象进行赋值条件 构造方法的方法名与类名相同 在该方法的方法名之前没有有返回值类型的声明 在该方法中不能使用return语句返回一个值，但是可以用return ;来表示该方法的结束 构造方法的语法123456789101112[修饰符] 方法名 ([参数列表])&#123; //方法体&#125;class A&#123; public A(int a) //构造方法 &#123; a=3; &#125;&#125; 构造方法的重载 与普通方法的重载相同，根据不同参数类型和数量自动重载相应重载对应的变量","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（三）——类、成员变量、成员方法","slug":"Java——基础知识（三）——类、成员变量、成员方法","date":"2021-05-05T16:00:00.000Z","updated":"2021-05-05T16:00:00.000Z","comments":true,"path":"2021/05/06/Java——基础知识（三）——类、成员变量、成员方法/","link":"","permalink":"http://example.com/2021/05/06/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E7%B1%BB%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/","excerpt":"","text":"类具有相同属性的对象的集合体 类可以近似理解为C语言中的结构体，只不过类更加灵活 类的创建 定义类的格式 1[修饰符(访问控制符)] class 类名 [extends 父类名][implements 接口名] 注意： 修饰符、父类名和接口名为可选项 类名首字母要大写 extends关键字用于说明该类继承于哪一个类 implements关键字用于说明该类实现了哪些接口 类必须编写在.java文件中 一个.java文件中，可以存在N个类，但是只能存在一个public修饰的类 .java文件的文件名必须与public修饰的类名完全一致 同一个包中不能有重名的类 成员变量 类中的变量定义成员变量123[修饰符] 数据类型 变量名 &#123;值&#125;;public String name; //定一个名为name的String型变量；private int age = 20; //定义一个名叫age的成员变量并赋值为20； 在Java中成员变量会自动初始化为0 调用成员变量 以类名为A、成员变量名为a为例 1A.a = 1; 成员方法 类中对成员变量进行操作的方法（函数） 定义成员方法123456[修饰符] [返回值类型] 方法名 (参数名)&#123; 方法内容return 返回值;&#125; 调用成语方法 以类名为A、成员方法名a为例 1A.a(); 对象的创建（实例化对象）与使用12345类名 对象名称 = new 类名();A m = new A(); //实例化对象A.成员变量/成员方法 //使用对象","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（二）——基本数据类型","slug":"Java——基础知识（二）——基本数据类型","date":"2021-05-02T16:00:00.000Z","updated":"2021-05-02T16:00:00.000Z","comments":true,"path":"2021/05/03/Java——基础知识（二）——基本数据类型/","link":"","permalink":"http://example.com/2021/05/03/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"整数| 类型名 |占用空间 | 取值范围 ||–|–|–|–|–|–|| byte | 8bit | -128127 || short | 16bit |-3276832767 || int | 32bit |$-2^{31}$ ~ $2^{31}$-1 || long | 64bit |$-2^{63}$ ~ $2^{63}$-1 | 注意 使用long型变量时，如果数据大小超过了int的大小需要在数字后加L或l； 12long a = 123456798101111213L;long a = 123456798101111213l; 浮点数| 类型名 |占用空间 | 取值范围 ||–|–|–|–|–|–|| float | 32bit | 1.4x$10^{-45}$3.4x$10^{38}$, -1.4x $10^{-45}$-3.4x$10^{38}$ || double | 64bit |4.9x$10^{-324}$1.7x$10^{308}$, -4.9x $10^{-324}$1.7x$10^{308}$ | 注意Java中小数默认为double若想使用float须在数字末尾加F或f12float a = 123.4f;float a = 123.4F; 字符型同C/C++，可借助ASCII码布尔型同C++，仅有两个值true和false12boolean a = false;boolean a = true;","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（四）——访问控制符","slug":"Java——基础知识（四）——访问控制符","date":"2021-04-30T16:00:00.000Z","updated":"2021-04-30T16:00:00.000Z","comments":true,"path":"2021/05/01/Java——基础知识（四）——访问控制符/","link":"","permalink":"http://example.com/2021/05/01/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/","excerpt":"","text":"访问控制符(修饰符)的类型 public（公有）——所有类可访问 private（私有）——当前类可访问 protected（保护）——子类可访问 default（默认）——（包内访问）public成员或外部类在任何地方（包内、类内、不同包、不同类）都可访问private该成员只能在该类的内部访问protected该成员既可以被同一个包中的其他类访问，也可以被不同包中的子类访问default不填写访问控制符则为默认控制符。同包内可以任意访问访问控制符权限表| |public|private | protected| default||–|–|–|–|–|–|–|–|| 同类 | Y| Y | Y |Y|| 同包不同类 | Y | | Y|Y|| 不同包 | Y | | Y | || 全局 |Y | | | |","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"},{"title":"Java——基础知识（一）——面向对象","slug":"Java——基础知识（一）——面向对象","date":"2021-04-29T16:00:00.000Z","updated":"2021-04-29T16:00:00.000Z","comments":true,"path":"2021/04/30/Java——基础知识（一）——面向对象/","link":"","permalink":"http://example.com/2021/04/30/Java%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象就是把构成问题的事物分解成一个个对象，从而能够较为方便的描述某个事物在解决问题中的行为。面向对象的特点封装封装是面向对象的核心思想，，将对象的属性和行为封装起来，不需要让外界具体的实现细节。例如：用户会使用电脑但用户不能私自挪动电脑内的硬件。继承继承主要描述类与类之间的关系，利用继承可以在不改变原有类的功能的前提下，对该类进行扩展。多态在Java中，类的继承、 方法的重写、父类的引用（类似指针）指向子类对象都能体现多态 例如：一个类被继承后，子类与父类调用同一个方法所呈现出的不同的行为特征。 对象 对象是基友一种特殊的变量，不仅能够存储数据，还能够对数据进行操作。 对象的成员：对象中的变量 类具有相同属性的对象的集合体 注意事项 类必须编写在.java文件中 一个.java文件中，可以存在N个类，但是只能存在一个public修饰的类 .java文件的文件名必须与public修饰的类名完全一致 同一个包中不能有重名的类","categories":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"UDK"}],"categories":[{"name":"HTML学习记录","slug":"HTML学习记录","permalink":"http://example.com/categories/HTML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"Java基础知识","slug":"Java基础知识","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]}